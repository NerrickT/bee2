#!/usr/bin/env ruby

require 'yaml'
require 'optparse'
require 'logger'
require_relative 'lib/vultr'
require_relative 'lib/dockerhandler'

log = Logger.new(STDOUT)

options = {}
opts = OptionParser.new do |opts|

  opts.banner = 'Usage: bee2 [-v] [-h|--help] [-c <config>] [-p [-r]] [-d COMMAND]'

  opts.on('-c','--config CONFIG','Configuration File') do |config|
    options[:config] = config
  end

  opts.on('-p', '--provision', 'Provision Servers') do |provision|
    options[:provision] = provision
  end

  opts.on('-d', '--docker COMMAND', 'Docker Command (use command \'help\' for more information)') do |docker|
    options[:docker] = docker
  end

  opts.on('-v', '--verbose', 'Debug Logging Output Enabled') do |verbose|
    if verbose
      log.level = Logger::DEBUG
    end
  end

  opts.on('-r','--rebuild','Destroy and Rebuild Servers During Provisioning') do |rebuild|
    options[:rebuild] = rebuild
  end

  opts.on('-a', '--ansible INVENTORY', [:public, :private], 'Run Ansible on Inventory (public|private)') do |ansible|
    options[:inventory] = ansible
  end

  #opts.on('-s', '--servers SERVERS', '')

  opts.on_tail("-h", "--help", "Show this message") do
    STDERR.puts opts
    exit
  end
end

begin opts.parse! ARGV
rescue *[OptionParser::InvalidOption,OptionParser::InvalidArgument,OptionParser::MissingArgument] => e
  STDERR.puts e
  STDERR.puts opts
  exit 1
end

if options[:config].nil?
  log.fatal('You must specify a config file (-c). Use -h for usage.')
  exit 1
end

config = YAML.load_file(options[:config])
case config['provisioner']['type']
when 'vultr'
  p = VultrProvisioner.new(config, log)
when 'digitalocean'
  @log.warn('Not Implemented')
  abort("Digital Ocean Not Implemented")
end

if options[:rebuild]
  puts 'WARNING: Rebuilding will destroy existing servers. Do you wish to contine? [Type: YES]'
  if gets.chomp != 'YES'
    puts 'Rebuild aborted'
    exit 5
  end
end
p.provision(rebuild = options[:rebuild])

if options[:inventory]
  inv_file = config['inventory'][options[:inventory].to_s]

  # Format: filename:server, e.g public:web, or just filename (public/private)
  # inv = config['inventory'][options[:inventory].to_s].partition(':')
  # inv_file = inv.first
  # hosts = inv.last

  playbooks = config['servers'].flat_map { |server, info| {server => info['playbook']} }.inject(:update)
  log.info("Running Ansible (Inventory: #{options[:inventory]} :: #{inv_file})")
  playbooks.each { |server, playbook|
    # if not hosts.empty? and not hosts.split(',').include?(server)
    #   next
    # end
    log.info("Applying #{playbook} to #{server}")
    cmd = ['ansible-playbook', '--limit', server, '--key-file', config['provisioner']['ssh_key']['private'],
           '-u', 'root', '-e', "config_file=#{options[:config].to_s}", '-i', inv_file,
           "ansible/ssh-hostkey-check.yml", "ansible/#{playbook}"]
    log.debug(cmd)
    Process.fork do
      exec(*cmd)
    end
    Process.wait
  }
end

if options[:docker]
  docker = DockerHandler.new(config, log, options[:docker])
end
